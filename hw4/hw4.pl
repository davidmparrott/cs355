/*
David Parrott
11239947
CS 355 Homework 4
Prolog implementation of Boolean Satisfiability Problem
collaboration with Brett Carter, Casey Gilray, Marissa
*/

/*
BASE CASE 

Returns:
A truth value associated with a variable returned in 'C'
A is variable we are looking for the truth value of.
If A is the variable in the leading pair of the list passed then we have located the 
pair we are searching for.
*/
eval-var(A,[[A,C]|_],C).

/*
CASE:
Lead variable is not the one we are looking for

Returns:
A truth value associated with a variable returned in 'C'
A is the variable we are looking for the truth value of.
If A is not variable in the leading pair of the list passed we recurse by setting
T to be the list minus the leading pair and call eval-var(A,T,X)
*/
eval-var(A,[_|T],X):-
    eval-var(A,T,X).

/*
BASE CASE
List is empty so return false. 
*/
eval-clause(_,[],false).

/*
CASE:
Lead entry in the list is a single item. Assumption is that it is a variable which
we must evaluate the truth value of.

Returns:
A truth value generated by 'OR'ing the components of a clause together in 'X'

eval-var is called on the leading term, H, 
which is what we need the truth value for, A, which is the list of truth values
for variables and a new variable, Z, which will hold the return value from eval-var().
If Z is set to true then we know the clause will evaluate to true, and the return value,
X, is set to true. Else eval-clause is called on the remainer of the list, T,
*/
eval-clause(A,[H|T],X):-
    eval-var(H,A,Z),
    (Z =@= true ->
     X = Z;
     eval-clause(A,T,X)
    ).

/*
CASE:
Lead entry in the list is not a single item. Assumption is that this is a negation
statement. 

Returns:
A truth value generated by 'OR'ing the components of a clause together in 'X'

We must evaluate the truth value of the variable in the leading item
and invert it. Z will store the return value from eval-var called on T, which is 
the term after 'not' in the leading item. If Z is true, we must continue searching
through the list by calling eval-clause(A, Y, X) where Y holds the remainder of the
list once the leading item has been removed. Finally after returning from that we are
able to set X to true and return.
*/
eval-clause(A,[[_,T]|Y],X):-
     eval-var(T,A,Z),
     (Z =@= true ->
      eval-clause(A,Y,X);
      X = true
      ).

/*
Removes brackets from a list. Removes the string 'not' from a list.
Returns:
A list of variables in 'X'
*/
get-vars(A,X):-
    flatten(A,Z),
    list_to_set(Z,Y),
    delete(Y,not,X).

/*
Removes brackets from a list. Removes the string 'not' from a list.
Returns:
A list of variables in 'X'
*/
get-all-vars(A,X):-
    flatten(A,Z),
    list_to_set(Z,Y),
    delete(Y,not,X).

/*
BASE CASE
list is empty so return an empty list
*/
unsat-clauses([],_,[]).

/*
CASE:
List is not empty

Assumptions:
A clause list is passed first with the correct format followed by a state list
with the correct format.

Return:
A list of clauses that evalute to 'false' stored in 'Z'.

Calls eval-clause on the leading item in a list. Declares new variable, F, 
and sets it to false. If P, which holds the return value from eval-clause, 
is also false, call unsat-clauses on the list after removing the leading item
and store the value in Rest. Append Rest to the leading item and store it in
Z to be returned by unsat-clauses. Else call unsat-clauses passing the list
after removing the leading term and passing Z as the return value.
*/
unsat-clauses([H|T], X, Z):- 
    eval-clause(X,H,P), 
    F = false, 
    (F == P -> 
     unsat-clauses(T,X,Rest), 
     append([H],Rest,Z); 
     unsat-clauses(T,X,Z)
     ).

/*
Inverts the truth value of a specified variable. 
In the first two cases, the lead item in the list contains the variable 
associated with the truth value we are attempting to invert, H. 
A new variable, Y, is created and assigned 'true' then a comparison is made 
between Y and the truth value of H, 'T'. 
*/

/*
CASE:
Lead varibale matches the variable we are searching for AND has a truth
value of 'true' associated with it.

Returns:
A list with an inverted truth value in the lead pair, 'U', and the remainder
of the original list appended to it
*/
flip-var(H,[[H,T]|Z],[[H,U]|Z]):-
    Y = true,
    T == Y,
    U = false.
/*
CASE:
Lead variable matches the variable we are searching for AND has a truth
value of 'false' associated with it.

Returns:
A list with an inverted truth value in the lead pair, 'U', and the remainder
of the original list appended to it
*/
flip-var(H,[[H,T]|Z],[[H,U]|Z]):-
    Y = true,
    T \== Y,
    U = true.

/*
CASE:
Lead variable, 'H', does not match the variable we are searching for, 'A'

Returns:
A list with the altered tail, 'Z', appended to the unaltered head.
*/
flip-var(A,[H|T],[H|Z]):-
    flip-var(A,T,Z).
